https://chatgpt.com/c/689c5297-dcb8-8323-ba6f-abc2d4178bad
https://chatgpt.com/c/689c5665-3454-8325-a74b-d7c7f0aa326e
https://chatgpt.com/c/689f8775-f704-8325-b916-b524c7dee478


Topic 11 ‚Äî Rebasing in Git.    Problem in rebasing theory as well as its commands
Rebase = Moving or combining a sequence of commits to a new base commit.
Instead of merging (which creates a merge commit), rebase rewrites history so your commits appear on top of another branch‚Äôs commits.

1. Why Rebase?
Cleaner history ‚Äî looks like work happened in a straight line.
Avoids extra merge commits.
Makes it easier to understand project history.

2. Merge vs Rebase
Merge:
main:    A---B---C
               \
feature:        D---E
merge result:   A---B---C---M
                     \     /
                      D---E

Rebase:
main:    A---B---C
                 \
feature:          D'---E'
Here D and E are rewritten as D' and E' on top of main.


3. Hands-on: Basic Rebase in VS Code
Step 1 ‚Äî Setup branches
# Create a main commit
echo "line 1" > file.txt
git add file.txt
git commit -m "Add line 1"
# Create feature branch
git checkout -b feature/rebase-demo
echo "line 2 from feature" >> file.txt
git commit -am "Add line 2 from feature"

Step 2 ‚Äî Switch to main and add change
git checkout main
echo "line 2 from main" >> file.txt
git commit -am "Add line 2 from main"

Step 3 ‚Äî Rebase feature branch onto main
git checkout feature/rebase-demo
git rebase main
If no conflicts ‚Üí commits from feature/rebase-demo are replayed on top of main.

Step 4 ‚Äî Handling conflicts in rebase
If conflict appears:
VS Code will highlight conflict markers (<<<<<<< etc.)
Fix the file manually.
Mark conflict resolved:
git add file.txt
git rebase --continue
If you want to cancel:
git rebase --abort

4. Interactive Rebase
Lets you reorder, edit, squash, or drop commits.
git rebase -i HEAD~3
You‚Äôll see:
pick abc123 Commit message 1
pick def456 Commit message 2
pick ghi789 Commit message 3

Commands:
pick ‚Üí keep commit as is
reword ‚Üí edit commit message
squash ‚Üí combine with previous commit
drop ‚Üí remove commit

5. Important Notes
Don‚Äôt rebase public/shared branches (can break teammates‚Äô history).
Safe to rebase your local feature branches before merging into main.











Topic 12 ‚Äî Viewing History
Goal: Learn how to view and filter Git commit history, so you can easily track changes and understand project evolution.
1Ô∏è‚É£ Basic Commands
View commit history:    git log.    
Shows commit hash, author, date, and message.
Short, one-line view:     git log --oneline
Show graph of branches:      git log --oneline --graph --all --decorate

2Ô∏è‚É£ Filtering Commits
By author:   git log --author="Ayush"
By date:   git log --since="2 days ago"
git log --until="2025-08-15"
<<<<<<< HEAD
By file:  git log -- <file_name>    like git log -- notes.txt
=======
By file:  git log -- <file_name>
>>>>>>> 80516bbbecc9abe91d860e7fe34a234ef243804d

3Ô∏è‚É£ Pretty Formats
Customize log output:
git log --pretty=oneline
git log --pretty=format:"%h - %an, %ar : %s"
%h ‚Üí short commit hash
%an ‚Üí author name
%ar ‚Üí relative date
%s ‚Üí commit message

4Ô∏è‚É£ Hands-on Exercise
1. Make a few commits on any branch:
echo "History Test 1" >> file.txt
git add file.txt
git commit -m "History Test 1"
echo "History Test 2" >> file.txt
git add file.txt
git commit -m "History Test 2"

2. View commits in different ways:
git log --oneline
git log --pretty=format:"%h - %an, %ar : %s"
git log --graph --all --decorate

3. Filter commits by author or file:
git log --author="Ayush"
git log -- file.txt

‚úÖ Tip: Knowing how to view history is essential for debugging, understanding past work, and preparing for rebases or merges.









Topic 13 ‚Äî Branching Strategies
Goal: Learn professional workflows for Git branching and choose the right strategy for your team or project.

1Ô∏è‚É£ Concept
Branching strategies help teams work together efficiently and manage releases and features without conflicts. The main strategies are:

Gitflow
Main branches:
main ‚Üí production-ready code
develop ‚Üí integration branch for features
Supporting branches:
feature/xyz ‚Üí new features, merged into develop
release/v1.0 ‚Üí prepare for a new release
hotfix/xyz ‚Üí urgent fixes on main
Pros: Clear structure, great for large teams
Cons: Slightly complex, more overhead

Trunk-based Development
Single main branch (main)
Developers make small, frequent commits directly or via short-lived feature branches
Pros: Simple, encourages CI/CD
Cons: Risk of breaking main if tests aren‚Äôt robust

Forking Workflow
Each contributor forks the repository
Work is done on feature branches in the fork
Pull Requests (PRs) are submitted to the main repo
Pros: Good for open-source and external contributions
Cons: More overhead for PR reviews

2Ô∏è‚É£ Commands & Examples
Create a new branch:     git checkout -b feature-login
Switch between branches:    git checkout develop
List all branches:
git branch      # local branches
git branch -a   # local + remote branches
Delete a branch:    git branch -d feature-login
Push branch to remote:      git push origin feature-login
Merge a feature into develop (Gitflow example):       
git checkout develop
git merge feature-login

3Ô∏è‚É£ Hands-on Exercise

1. Simulate a Gitflow workflow:
git checkout main
git checkout -b develop          # create develop branch
git checkout -b feature-login    # create feature branch
# Make a commit in feature-login
echo "Login feature" >> file.txt
git add file.txt
git commit -m "Add login feature"
git checkout develop
git merge feature-login          # merge feature into develop

2. Switch to Trunk-based workflow:
git checkout main
git checkout -b feature-dashboard
# Make small commit
echo "Dashboard feature" >> file.txt
git add file.txt
git commit -m "Add dashboard feature"
git checkout main
git merge feature-dashboard

3. Optional: Try Forking workflow on GitHub:
Fork a repo
Create a feature branch in your fork
Make changes, push to fork
Open Pull Request to original repo

4Ô∏è‚É£ Key Tips
Always use meaningful branch names: feature/login, hotfix/payment-bug
Keep feature branches short-lived
Pull latest changes from develop or main frequently to avoid conflicts











Topic 14 ‚Äî Adding Commits
Goal: Learn how to stage changes, create commits, and maintain a clean, meaningful commit history.

1Ô∏è‚É£ Concept
A commit is a snapshot of your project at a point in time.
You stage changes first (git add) before committing them (git commit).
Good commit messages help others understand the changes and make code reviews easier.

2Ô∏è‚É£ Commands & Examples
Stage a single file:    git add file.txt
Stage all changes:    git add .
Commit staged changes with a message:    git commit -m "Add login feature"
Commit tracked files without staging separately:     git commit -am "Update dashboard layout"
Amend the last commit (if you forgot something):     
git add missing_file.txt
git commit --amend

3Ô∏è‚É£ Best Practices
1. Write clear, concise messages:
Format: <type>: <short description>
Example: feat: add user login functionality
Types: feat (feature), fix (bug fix), docs (documentation), refactor, style, test
2. Keep commits small and focused:
One commit = one logical change
3. Stage only necessary files:
Avoid committing temporary or unrelated files

4Ô∏è‚É£ Hands-on Exercise
1. Create a new branch:     git checkout -b feature-login

2. Make a few changes:
echo "Login page setup" >> file.txt
git add file.txt
git commit -m "feat: add login page setup"
echo "Add validation" >> file.txt
git add file.txt
git commit -m "feat: add login form validation"
echo "Fix typo" >> file.txt
git add file.txt
git commit -m "fix: correct typo in login messages"

3. View commits:    git log --oneline

4. Amend the last commit if needed:    git commit --amend -m "fix: correct typo in login messages (updated)"
Little problem in amend

‚úÖ Tip: Good commit hygiene makes rebasing, merging, and PR reviews much easier












Topic 15 ‚Äî Removing Commits.     Havent practiced the commands
Goal: Learn how to undo commits, whether you want to keep the changes, discard them, or revert them safely.

1Ô∏è‚É£ Concept
There are three main ways to remove or undo commits in Git:

1. Soft Reset (--soft)
Moves HEAD to a previous commit
Keeps changes in staging area
Useful when you want to redo a commit
git reset --soft HEAD~1

2. Mixed Reset (default)
Moves HEAD and unstages changes
Keeps changes in working directory
git reset HEAD~1

3. Hard Reset (--hard)
Moves HEAD and discards changes completely
Use with caution
git reset --hard HEAD~1

4. Revert
Creates a new commit that undoes a previous commit
Safe for public/shared branches
git revert <commit_hash>

2Ô∏è‚É£ Commands & Examples
Undo last commit but keep changes staged (soft reset):   git reset --soft HEAD~1
Undo last commit and unstage changes (mixed reset):   git reset HEAD~1
Undo last commit and discard changes (hard reset):   git reset --hard HEAD~1
Revert a commit safely in a shared branch:    git revert a1b2c3d
View commit history to choose which commit to remove:    git log --oneline

3Ô∏è‚É£ Hands-on Exercise

1. Make 3 commits on a branch:
echo "Test 1" >> file.txt
git add file.txt
git commit -m "Test 1"
echo "Test 2" >> file.txt
git add file.txt
git commit -m "Test 2"
echo "Test 3" >> file.txt
git add file.txt
git commit -m "Test 3"

2. Undo last commit but keep changes staged:     git reset --soft HEAD~1

3. Undo second commit but discard changes:    git reset --hard HEAD~2

4. Make a commit and revert it safely:    
echo "Test 4" >> file.txt
git add file.txt
git commit -m "Test 4"
git revert HEAD

‚úÖ Tip:
Use reset for local commits not shared with others
Use revert for commits that are already pushed or shared












Topic 16 ‚Äî Squashing Commits
üéØ Goal: Learn how to combine multiple commits into one clean commit using interactive rebase, so that history is easy to read and professional.

1Ô∏è‚É£ Concept
When working on a feature, we often make multiple small commits like:
fix typo
added console.log
final fix
‚û°Ô∏è These look messy in the main branch.
üëâ Squashing lets you combine them into one meaningful commit (e.g., Add login feature).

Key Method: Interactive Rebase
git rebase -i HEAD~N
N = number of commits from HEAD you want to squash.
Opens an editor where you can choose which commits to squash into the first one.

2Ô∏è‚É£ Commands & Examples
Start interactive rebase for last 3 commits:
git rebase -i HEAD~3
Change pick to squash (or s) for commits you want to merge into the one above:
pick d1f8e76 Add line 1
squash a7b4e21 Add line 2
squash c3f9a8d Add line 3

Edit commit message to something clean:
Add demo.txt with lines 1‚Äì3

View history after squashing:
git log --oneline
Result ‚Üí One commit instead of three. ‚úÖ

3Ô∏è‚É£ Hands-on Exercise

Step 1: Create demo repo and make 3 commits
mkdir git-squash-demo
cd git-squash-demo
git init
echo "Line 1" > demo.txt
git add .
git commit -m "Add line 1"
echo "Line 2" >> demo.txt
git add .
git commit -m "Add line 2"
echo "Line 3" >> demo.txt
git add .
git commit -m "Add line 3"
git log --oneline

Step 2: Start interactive rebase for last 3 commits
git rebase -i HEAD~3

Step 3: Mark commits to squash
In the editor:
pick d1f8e76 Add line 1
squash a7b4e21 Add line 2
squash c3f9a8d Add line 3

Step 4: Edit commit message
Add demo.txt with lines 1‚Äì3

Step 5: Verify
git log --oneline
Now you‚Äôll see only 1 clean commit. üéâ

‚úÖ Tip
Use squash before merging feature branches into main.
Keep commits atomic and meaningful.
Avoid squashing commits that are already pushed/shared, unless you‚Äôre sure (rewrites history).
If already pushed, use merge --squash instead.












Topic 17 ‚Äî Amending Commits
üéØ Goal: Learn how to modify the most recent commit ‚Äî either the message or the content (files).

1Ô∏è‚É£ Concept
Sometimes after committing, you realize:
You forgot to add a file
The commit message has a typo
You want to adjust the commit content
üëâ Instead of making a new commit, you can amend the last one.
Key Command:    git commit --amend

Options:
Amend commit message only
Amend commit content (files + message)

2Ô∏è‚É£ Commands & Examples
Change the last commit message
git commit --amend -m "New commit message"
Add a forgotten file to the last commit
git add missing_file.txt
git commit --amend
Amend without changing the message (keep same message, only content changes)
git commit --amend --no-edit
View commit history to confirm changes
git log --oneline

3Ô∏è‚É£ Hands-on Exercise

Step 1: Create a repo and make a commit
mkdir git-amend-demo
cd git-amend-demo
git init
echo "Hello" > file.txt
git add file.txt
git commit -m "Add file.txt"

Step 2: Realize commit message is wrong ‚Üí fix it
git commit --amend -m "Add initial file.txt"

Step 3: Forget to add another file ‚Üí amend commit with content
echo "Extra content" > extra.txt
git add extra.txt
git commit --amend --no-edit

Step 4: Check log
git log --oneline
You‚Äôll see only one commit containing both file.txt and extra.txt.

‚úÖ Tip
Use amend only if you haven‚Äôt pushed yet.
If you already pushed ‚Üí amending rewrites history, which can confuse collaborators.
Safe rule: Amend locally, Revert if already pushed.










Topic 18 ‚Äî Deleting Commits
üéØ Goal: Learn how to remove unwanted commits from history, either locally or in a shared branch.

1Ô∏è‚É£ Concept
There are a few ways to delete commits in Git depending on the situation:

1. Reset (local only)
Removes commits by moving HEAD back
Use for local branches not yet pushed
Types: --soft, --mixed, --hard
git reset --hard HEAD~1

2. Rebase (interactive delete)
Lets you choose which commits to drop
Good for cleaning up history before pushing
git rebase -i HEAD~N

3. Revert (safe delete)
Does not remove commits
Creates a new commit that undoes a previous one
Safe for shared/public branches
git revert <commit_hash>

2Ô∏è‚É£ Commands & Examples
Delete last commit completely (local only)
git reset --hard HEAD~1

Delete specific commit interactively
git rebase -i HEAD~3

In the editor, replace pick with drop:
pick d1f8e76 Add file.txt
drop a7b4e21 Fix typo
pick c3f9a8d Add new feature

Revert a commit safely in shared history
git revert <commit_hash>

View history after deleting commits
git log --oneline

3Ô∏è‚É£ Hands-on Exercise

Step 1: Make 3 commits
mkdir git-delete-demo
cd git-delete-demo
git init
echo "Line 1" > file.txt
git add file.txt
git commit -m "Commit 1"
echo "Line 2" >> file.txt
git add file.txt
git commit -m "Commit 2"
echo "Line 3" >> file.txt
git add file.txt
git commit -m "Commit 3"
git log --oneline

Step 2: Delete last commit completely
git reset --hard HEAD~1

Step 3: Delete a middle commit using rebase
git rebase -i HEAD~2
In the editor ‚Üí mark commit 2 as drop, save, and exit.

Step 4: Revert a commit safely (if pushed)
echo "Line 4" >> file.txt
git add file.txt
git commit -m "Commit 4"
git revert HEAD

‚úÖ Tip
Use reset or rebase for local commits only.
Use revert when working with a team (safe & non-destructive).
Always check history with git log --oneline after changes.
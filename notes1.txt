https://chatgpt.com/c/689c5297-dcb8-8323-ba6f-abc2d4178bad
https://chatgpt.com/c/689c5665-3454-8325-a74b-d7c7f0aa326e
https://chatgpt.com/c/689f8775-f704-8325-b916-b524c7dee478


Topic 11 — Rebasing in Git.    Problem in rebasing theory as well as its commands
Rebase = Moving or combining a sequence of commits to a new base commit.
Instead of merging (which creates a merge commit), rebase rewrites history so your commits appear on top of another branch’s commits.

1. Why Rebase?
Cleaner history — looks like work happened in a straight line.
Avoids extra merge commits.
Makes it easier to understand project history.

2. Merge vs Rebase
Merge:
main:    A---B---C
               \
feature:        D---E
merge result:   A---B---C---M
                     \     /
                      D---E

Rebase:
main:    A---B---C
                 \
feature:          D'---E'
Here D and E are rewritten as D' and E' on top of main.


3. Hands-on: Basic Rebase in VS Code
Step 1 — Setup branches
# Create a main commit
echo "line 1" > file.txt
git add file.txt
git commit -m "Add line 1"
# Create feature branch
git checkout -b feature/rebase-demo
echo "line 2 from feature" >> file.txt
git commit -am "Add line 2 from feature"

Step 2 — Switch to main and add change
git checkout main
echo "line 2 from main" >> file.txt
git commit -am "Add line 2 from main"

Step 3 — Rebase feature branch onto main
git checkout feature/rebase-demo
git rebase main
If no conflicts → commits from feature/rebase-demo are replayed on top of main.

Step 4 — Handling conflicts in rebase
If conflict appears:
VS Code will highlight conflict markers (<<<<<<< etc.)
Fix the file manually.
Mark conflict resolved:
git add file.txt
git rebase --continue
If you want to cancel:
git rebase --abort

4. Interactive Rebase
Lets you reorder, edit, squash, or drop commits.
git rebase -i HEAD~3
You’ll see:
pick abc123 Commit message 1
pick def456 Commit message 2
pick ghi789 Commit message 3

Commands:
pick → keep commit as is
reword → edit commit message
squash → combine with previous commit
drop → remove commit

5. Important Notes
Don’t rebase public/shared branches (can break teammates’ history).
Safe to rebase your local feature branches before merging into main.











Topic 12 — Viewing History
Goal: Learn how to view and filter Git commit history, so you can easily track changes and understand project evolution.
1️⃣ Basic Commands
View commit history:    git log.    
Shows commit hash, author, date, and message.
Short, one-line view:     git log --oneline
Show graph of branches:      git log --oneline --graph --all --decorate

2️⃣ Filtering Commits
By author:   git log --author="Ayush"
By date:   git log --since="2 days ago"
git log --until="2025-08-15"
<<<<<<< HEAD
By file:  git log -- <file_name>    like git log -- notes.txt
=======
By file:  git log -- <file_name>
>>>>>>> 80516bbbecc9abe91d860e7fe34a234ef243804d

3️⃣ Pretty Formats
Customize log output:
git log --pretty=oneline
git log --pretty=format:"%h - %an, %ar : %s"
%h → short commit hash
%an → author name
%ar → relative date
%s → commit message

4️⃣ Hands-on Exercise
1. Make a few commits on any branch:
echo "History Test 1" >> file.txt
git add file.txt
git commit -m "History Test 1"
echo "History Test 2" >> file.txt
git add file.txt
git commit -m "History Test 2"

2. View commits in different ways:
git log --oneline
git log --pretty=format:"%h - %an, %ar : %s"
git log --graph --all --decorate

3. Filter commits by author or file:
git log --author="Ayush"
git log -- file.txt

✅ Tip: Knowing how to view history is essential for debugging, understanding past work, and preparing for rebases or merges.









Topic 13 — Branching Strategies
Goal: Learn professional workflows for Git branching and choose the right strategy for your team or project.

1️⃣ Concept
Branching strategies help teams work together efficiently and manage releases and features without conflicts. The main strategies are:

Gitflow
Main branches:
main → production-ready code
develop → integration branch for features
Supporting branches:
feature/xyz → new features, merged into develop
release/v1.0 → prepare for a new release
hotfix/xyz → urgent fixes on main
Pros: Clear structure, great for large teams
Cons: Slightly complex, more overhead

Trunk-based Development
Single main branch (main)
Developers make small, frequent commits directly or via short-lived feature branches
Pros: Simple, encourages CI/CD
Cons: Risk of breaking main if tests aren’t robust

Forking Workflow
Each contributor forks the repository
Work is done on feature branches in the fork
Pull Requests (PRs) are submitted to the main repo
Pros: Good for open-source and external contributions
Cons: More overhead for PR reviews

2️⃣ Commands & Examples
Create a new branch:     git checkout -b feature-login
Switch between branches:    git checkout develop
List all branches:
git branch      # local branches
git branch -a   # local + remote branches
Delete a branch:    git branch -d feature-login
Push branch to remote:      git push origin feature-login
Merge a feature into develop (Gitflow example):       
git checkout develop
git merge feature-login

3️⃣ Hands-on Exercise

1. Simulate a Gitflow workflow:
git checkout main
git checkout -b develop          # create develop branch
git checkout -b feature-login    # create feature branch
# Make a commit in feature-login
echo "Login feature" >> file.txt
git add file.txt
git commit -m "Add login feature"
git checkout develop
git merge feature-login          # merge feature into develop

2. Switch to Trunk-based workflow:
git checkout main
git checkout -b feature-dashboard
# Make small commit
echo "Dashboard feature" >> file.txt
git add file.txt
git commit -m "Add dashboard feature"
git checkout main
git merge feature-dashboard

3. Optional: Try Forking workflow on GitHub:
Fork a repo
Create a feature branch in your fork
Make changes, push to fork
Open Pull Request to original repo

4️⃣ Key Tips
Always use meaningful branch names: feature/login, hotfix/payment-bug
Keep feature branches short-lived
Pull latest changes from develop or main frequently to avoid conflicts











Topic 14 — Adding Commits
Goal: Learn how to stage changes, create commits, and maintain a clean, meaningful commit history.

1️⃣ Concept
A commit is a snapshot of your project at a point in time.
You stage changes first (git add) before committing them (git commit).
Good commit messages help others understand the changes and make code reviews easier.

2️⃣ Commands & Examples
Stage a single file:    git add file.txt
Stage all changes:    git add .
Commit staged changes with a message:    git commit -m "Add login feature"
Commit tracked files without staging separately:     git commit -am "Update dashboard layout"
Amend the last commit (if you forgot something):     
git add missing_file.txt
git commit --amend

3️⃣ Best Practices
1. Write clear, concise messages:
Format: <type>: <short description>
Example: feat: add user login functionality
Types: feat (feature), fix (bug fix), docs (documentation), refactor, style, test
2. Keep commits small and focused:
One commit = one logical change
3. Stage only necessary files:
Avoid committing temporary or unrelated files

4️⃣ Hands-on Exercise
1. Create a new branch:     git checkout -b feature-login

2. Make a few changes:
echo "Login page setup" >> file.txt
git add file.txt
git commit -m "feat: add login page setup"
echo "Add validation" >> file.txt
git add file.txt
git commit -m "feat: add login form validation"
echo "Fix typo" >> file.txt
git add file.txt
git commit -m "fix: correct typo in login messages"

3. View commits:    git log --oneline

4. Amend the last commit if needed:    git commit --amend -m "fix: correct typo in login messages (updated)"
Little problem in amend

✅ Tip: Good commit hygiene makes rebasing, merging, and PR reviews much easier
